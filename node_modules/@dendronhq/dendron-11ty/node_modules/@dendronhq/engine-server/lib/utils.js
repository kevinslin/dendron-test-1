"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripLocalOnlyTags = exports.matchRefMarker = exports.parseFileLinkV2 = exports.parseFileLink = exports.parseDendronRef = exports.writeWSMetaFile = exports.openWSMetaFile = exports.openPortFile = exports.getWSMetaFilePath = exports.getPortFilePath = exports.getEngine = exports.refLink2Stringv2 = exports.refLink2String = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const engineClient_1 = require("./engineClient");
function normalize(text) {
    return lodash_1.default.toLower(lodash_1.default.trim(text, " #"));
}
function normalizev2(text, slugger) {
    const u = lodash_1.default.trim(text, " #");
    if (u === "*") {
        return u;
    }
    return slugger.slug(u);
}
/**
 * take a ref link and parse it as regular markdown
 */
function refLink2String(link, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, {
        includeParen: false,
        includeRefTag: false,
    });
    const { anchorStart, anchorStartOffset, anchorEnd } = link.data;
    const { fname: name } = link.from;
    // [[foo]]#head1:#*"
    const linkParts = [`[[${name}]]`];
    if (anchorStart) {
        linkParts.push(`#${normalize(anchorStart)}`);
    }
    if (anchorStartOffset) {
        linkParts.push(`,${anchorStartOffset}`);
    }
    if (anchorEnd) {
        linkParts.push(`:#${normalize(anchorEnd)}`);
    }
    if (cleanOpts.includeRefTag) {
        linkParts.splice(0, 0, "ref: ");
    }
    if (cleanOpts.includeParen) {
        linkParts.splice(0, 0, "((");
        linkParts.push("))");
    }
    return linkParts.join("");
}
exports.refLink2String = refLink2String;
function refLink2Stringv2(link) {
    const slugger = common_all_1.getSlugger();
    const { anchorStart, anchorStartOffset, anchorEnd } = link.data;
    const { fname: name } = link.from;
    // [[foo]]#head1:#*"
    const linkParts = [`![[`, name];
    if (anchorStart) {
        linkParts.push(`#${normalizev2(anchorStart, slugger)}`);
    }
    if (anchorStartOffset) {
        linkParts.push(`,${anchorStartOffset}`);
    }
    if (anchorEnd) {
        linkParts.push(`:#${normalizev2(anchorEnd, slugger)}`);
    }
    linkParts.push("]]");
    return linkParts.join("");
}
exports.refLink2Stringv2 = refLink2Stringv2;
async function getEngine(opts) {
    const { numTries, wsRoot, vaults } = lodash_1.default.defaults(opts, { numTries: 5 });
    if (numTries <= 0) {
        return {
            error: new common_all_1.DendronError({ msg: "exceeded numTries" }),
        };
    }
    return new Promise((resolve, _reject) => {
        try {
            const port = engineClient_1.DendronEngineClient.getPort({ wsRoot });
            const dendronEngine = engineClient_1.DendronEngineClient.create({
                port,
                ws: wsRoot,
                vaults: vaults.map((ent) => ent.fsPath),
            });
            resolve({
                data: dendronEngine,
            });
        }
        catch (err) {
            setTimeout(() => {
                resolve(getEngine({ ...opts, numTries: numTries - 1 }));
            }, 5000);
        }
    });
}
exports.getEngine = getEngine;
function getPortFilePath({ wsRoot }) {
    const portFile = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_SERVER_PORT);
    return portFile;
}
exports.getPortFilePath = getPortFilePath;
function getWSMetaFilePath({ wsRoot }) {
    const fsPath = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_WS_META);
    return fsPath;
}
exports.getWSMetaFilePath = getWSMetaFilePath;
function openPortFile({ fpath }) {
    return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" })));
}
exports.openPortFile = openPortFile;
function openWSMetaFile({ fpath }) {
    return fs_extra_1.default.readJSONSync(fpath);
}
exports.openWSMetaFile = openWSMetaFile;
function writeWSMetaFile({ fpath, data, }) {
    return fs_extra_1.default.writeJSONSync(fpath, data);
}
exports.writeWSMetaFile = writeWSMetaFile;
function parseDendronRef(ref) {
    const [idOrRef, ...rest] = lodash_1.default.trim(ref).split(":");
    const cleanArgs = lodash_1.default.trim(rest.join(":"));
    let link;
    let direction;
    if (idOrRef === "ref") {
        direction = "to";
        link = parseLink(cleanArgs);
    }
    else {
        throw Error(`parse non ref not implemented, ref: ${ref}`);
    }
    return { direction, link };
}
exports.parseDendronRef = parseDendronRef;
function parseFileLink(ref) {
    var _a;
    const wikiFileName = /([^\]:]+)/.source;
    const reLink = new RegExp("" +
        /\[\[/.source +
        `(?<name>${wikiFileName})` +
        /\]\]/.source +
        `(${new RegExp(
        // anchor start
        "" +
            /#?/.source +
            `(?<anchorStart>${wikiFileName})` +
            // anchor stop
            `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
    const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
    const clean = {
        type: "file",
    };
    let fname;
    lodash_1.default.each(groups, (v, k) => {
        if (lodash_1.default.isUndefined(v)) {
            return;
        }
        if (k === "name") {
            fname = path_1.default.basename(v, ".md");
        }
        else {
            // @ts-ignore
            clean[k] = v;
        }
    });
    if (lodash_1.default.isUndefined(fname)) {
        throw new common_all_1.DendronError({ msg: `fname for ${ref} is undefined` });
    }
    if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
        const [anchorStart, offset] = clean.anchorStart.split(",");
        clean.anchorStart = anchorStart;
        clean.anchorStartOffset = parseInt(offset);
    }
    return { from: { fname }, data: clean, type: "ref" };
}
exports.parseFileLink = parseFileLink;
function parseFileLinkV2(ref) {
    var _a;
    const wikiFileName = /([^\]:#]+)/.source;
    const reLink = new RegExp("" +
        `(?<name>${wikiFileName})` +
        `(${new RegExp(
        // anchor start
        "" +
            /#?/.source +
            `(?<anchorStart>${wikiFileName})` +
            // anchor stop
            `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
    const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
    const clean = {
        type: "file",
    };
    let fname;
    lodash_1.default.each(groups, (v, k) => {
        if (lodash_1.default.isUndefined(v)) {
            return;
        }
        if (k === "name") {
            fname = path_1.default.basename(v, ".md");
        }
        else {
            // @ts-ignore
            clean[k] = v;
        }
    });
    if (lodash_1.default.isUndefined(fname)) {
        throw new common_all_1.DendronError({ msg: `fname for ${ref} is undefined` });
    }
    if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
        const [anchorStart, offset] = clean.anchorStart.split(",");
        clean.anchorStart = anchorStart;
        clean.anchorStartOffset = parseInt(offset);
    }
    return { from: { fname }, data: clean, type: "ref" };
}
exports.parseFileLinkV2 = parseFileLinkV2;
function parseLink(ref) {
    if (ref.indexOf("]") >= 0) {
        return parseFileLink(ref);
    }
    else {
        throw Error(`parseLink, non-file link, not implemented, ${ref}`);
    }
}
exports.matchRefMarker = (txt) => {
    return txt.match(/\(\((?<ref>[^)]+)\)\)/);
};
function stripLocalOnlyTags(doc) {
    const re = new RegExp(/(?<raw>.+<!--LOCAL_ONLY_LINE-->)/);
    let matches;
    do {
        matches = doc.match(re);
        if (matches) {
            // @ts-ignore
            const { raw, body } = matches.groups;
            doc = doc.replace(raw, "");
        }
    } while (matches);
    return doc;
}
exports.stripLocalOnlyTags = stripLocalOnlyTags;
//# sourceMappingURL=utils.js.map