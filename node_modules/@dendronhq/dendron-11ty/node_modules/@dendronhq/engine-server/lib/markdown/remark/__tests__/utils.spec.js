"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const utils_2 = require("./utils");
const IMAGE_LINK = `![alt-text](image-url.jpg)`;
// --- Utils
const readAndProcess = (opts) => {
    const { npath, proc } = opts;
    const noteRaw = fs_extra_1.default.readFileSync(npath, { encoding: "utf8" });
    const respParse = proc.parse(noteRaw);
    const respProcess = proc.processSync(noteRaw);
    const respRehype = utils_1.MDUtilsV4.procRehype({ proc: proc() }).processSync(noteRaw);
    expect(respParse).toMatchSnapshot("respParse");
    expect(respProcess).toMatchSnapshot("respProcess");
    expect(respRehype).toMatchSnapshot("respRehype");
    return { proc, respProcess, respParse, respRehype };
};
const modifyNote = async (opts, cb) => {
    await common_test_utils_1.NoteTestUtilsV4.modifyNoteByPath({ wsRoot: opts.wsRoot, vault: opts.vaults[0], fname: "foo" }, cb);
};
const createProc = async (opts, procOverride) => {
    const { engine, vaults, extra } = opts;
    const proc = await utils_1.MDUtilsV4.procFull(lodash_1.default.defaults({
        engine,
        dest: extra.dest,
        fname: "foo",
        vault: vaults[0],
    }, procOverride));
    return proc;
};
// --- Test Cases
const WITH_TITLE = utils_2.createProcTests({
    name: "WITH_TITLE",
    setupFunc: async (opts) => {
        let proc = await createProc(opts, {
            publishOpts: {
                insertTitle: true,
            },
        });
        const npath = path_1.default.join(opts.wsRoot, opts.vaults[0].fsPath, "foo.md");
        return readAndProcess({ npath, proc });
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
            const { respProcess } = extra;
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: respProcess.contents,
                match: ["# Foo", "foo body"],
            })).toBeTruthy();
        },
    },
    preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
});
const WITH_VARIABLE = utils_2.createProcTests({
    name: "WITH_VARIABLE",
    setupFunc: async (opts) => {
        let proc = await createProc(opts);
        const npath = path_1.default.join(opts.wsRoot, opts.vaults[0].fsPath, "foo.md");
        return readAndProcess({ npath, proc });
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
            const { respProcess, respRehype } = extra;
            Promise.all([respProcess, respRehype].map(async (ent) => {
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: ent.contents,
                    match: ["Title: Foo", "Bond: 42"],
                })).toBeTruthy();
            }));
        },
        [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: types_1.DendronASTDest.MD_REGULAR,
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await modifyNote(opts, (note) => {
            note.custom = { bond: 42 };
            note.body = `Title: {{fm.title}}. Bond: {{fm.bond}}`;
            return note;
        });
    },
});
const WITH_ABBR = utils_2.createProcTests({
    name: "WITH_ABBR",
    setupFunc: async (opts) => {
        let proc = await createProc(opts);
        const npath = path_1.default.join(opts.wsRoot, opts.vaults[0].fsPath, "foo.md");
        return readAndProcess({ npath, proc });
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { respRehype } = extra;
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: respRehype.contents,
                match: [
                    `<p>This plugin works on <abbr title="Markdown Abstract Syntax Tree">MDAST</abbr>, a Markdown <abbr title="Abstract syntax tree">AST</abbr> implemented by <a href="https://github.com/remarkjs/remark">remark</a></p>`,
                ],
            })).toBeTruthy();
        },
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await modifyNote(opts, (note) => {
            note.body = [
                "This plugin works on MDAST, a Markdown AST implemented by [remark](https://github.com/remarkjs/remark)",
                "",
                "*[MDAST]: Markdown Abstract Syntax Tree",
                "*[AST]: Abstract syntax tree",
            ].join("\n");
            return note;
        });
    },
});
const WITH_FOOTNOTES = utils_2.createProcTests({
    name: "WITH_FOOTNOTES",
    setupFunc: async (opts) => {
        let proc = await createProc(opts);
        const npath = path_1.default.join(opts.wsRoot, opts.vaults[0].fsPath, "foo.md");
        return readAndProcess({ npath, proc });
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { respRehype, respProcess } = extra;
            expect(respProcess).toMatchSnapshot();
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: respRehype.contents,
                match: [
                    `Here is the footnote.<a href="#fnref-1" class="footnote-backref">â†©</a>`,
                ],
            })).toBeTruthy();
        },
        ...utils_2.generateVerifyFunction({ target: types_1.DendronASTDest.HTML }),
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await modifyNote(opts, (note) => {
            note.body = [
                "Here is a footnote reference,[^1]",
                "",
                "[^1]: Here is the footnote.",
            ].join("\n");
            return note;
        });
    },
});
const WITH_ASSET_PREFIX_UNDEFINED = utils_2.createProcTests({
    name: "asset_prefix undefined",
    setupFunc: async (opts) => {
        let proc = await createProc(opts, {
            publishOpts: {
                assetsPrefix: undefined,
            },
        });
        const resp = proc.processSync(IMAGE_LINK);
        return { resp, proc };
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
            const { resp } = extra;
            expect(resp).toMatchSnapshot();
            return [
                {
                    actual: lodash_1.default.trim(resp.toString()),
                    expected: "![alt-text](image-url.jpg)",
                },
            ];
        },
        [types_1.DendronASTDest.HTML]: types_1.DendronASTDest.MD_REGULAR,
        [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: types_1.DendronASTDest.MD_REGULAR,
    },
    preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
});
const WITH_ASSET_PREFIX = utils_2.createProcTests({
    name: "asset_prefix",
    setupFunc: async (opts) => {
        let proc = await createProc(opts, {
            publishOpts: {
                assetsPrefix: "bond/",
            },
        });
        const resp = proc.processSync(IMAGE_LINK);
        return { resp, proc };
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
            const { resp } = extra;
            expect(resp).toMatchSnapshot();
            return [
                {
                    actual: lodash_1.default.trim(resp.toString()),
                    expected: "![alt-text](image-url.jpg)",
                },
            ];
        },
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { resp } = extra;
            expect(resp).toMatchSnapshot();
            return [
                {
                    actual: lodash_1.default.trim(resp.toString()),
                    expected: "![alt-text](/bond/image-url.jpg)",
                },
            ];
        },
        [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: types_1.DendronASTDest.MD_REGULAR,
    },
    preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
});
const NOTE_REF_BASIC_WITH_REHYPE = utils_2.createProcTests({
    name: "NOTE_REF_WITH_REHYPE",
    setupFunc: async (opts) => {
        let proc = await createProc(opts, {
            wikiLinksOpts: { useId: true },
        });
        const txt = `((ref: [[foo.md]]))`;
        if (opts.extra.dest === types_1.DendronASTDest.HTML) {
            const procRehype = utils_1.MDUtilsV4.procRehype({ proc });
            const resp = await procRehype.process(txt);
            return { resp, proc };
        }
        else {
            const resp = await proc.process(txt);
            return { resp, proc };
        }
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async () => { },
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { resp } = extra;
            expect(resp).toMatchSnapshot("respRehype");
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: resp.contents,
                match: [
                    // link by id
                    `<a href=\"foo-id.html\"`,
                    // html quoted
                    `<p><a href=\"bar.html\">bar</a></p>`,
                ],
            })).toBeTruthy();
        },
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic({ ...opts, extra: { idv2: true } });
        await modifyNote(opts, (note) => {
            note.body = `[[bar]]`;
            return note;
        });
    },
});
const NOTE_W_LINK_AND_SPACE = utils_2.createProcTests({
    name: "NOTE_W_LINK_AND_SPACE",
    setupFunc: async (opts) => {
        let proc = await createProc(opts);
        const npath = path_1.default.join(opts.wsRoot, opts.vaults[0].fsPath, "foo.md");
        return readAndProcess({ npath, proc });
    },
    verifyFuncDict: {
        // NOTE: this shouldn't hapen since publishing should always be by id...
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { respRehype } = extra;
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: respRehype.contents,
                match: [`<a href=\"foo bar.html\"`],
            })).toBeTruthy();
        },
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic({ ...opts, extra: { idv2: true } });
        await modifyNote(opts, (note) => {
            note.body = `[[foo bar]]`;
            return note;
        });
    },
});
const NOTE_REF_RECURSIVE_BASIC_WITH_REHYPE = utils_2.createProcTests({
    name: "NOTE_REF_RECURSIVE_WITH_REHYPE",
    setupFunc: async (opts) => {
        let proc = await createProc(opts, {
            wikiLinksOpts: { useId: true },
        });
        const txt = `((ref: [[foo.md]]))`;
        if (opts.extra.dest === types_1.DendronASTDest.HTML) {
            const procRehype = utils_1.MDUtilsV4.procRehype({ proc });
            const resp = await procRehype.process(txt);
            const respParse = await procRehype.parse(txt);
            const respTransform = await procRehype.run(respParse);
            return { resp, proc, respParse, respTransform };
        }
        else {
            const resp = await proc.process(txt);
            return { resp, proc };
        }
    },
    verifyFuncDict: {
        [types_1.DendronASTDest.MD_REGULAR]: async () => { },
        [types_1.DendronASTDest.HTML]: async ({ extra }) => {
            const { resp, respParse, respTransform } = extra;
            expect(resp).toMatchSnapshot();
            expect(respParse).toMatchSnapshot();
            expect(respTransform).toMatchSnapshot();
            expect(await common_test_utils_1.AssertUtils.assertInString({
                body: resp.contents,
                match: [
                    // link by id
                    `<a href=\"foo-id.html\"`,
                    // html quoted
                    `Foo.One</h1>`,
                    `Foo.Two</h1>`,
                ],
            })).toBeTruthy();
        },
        [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async () => { },
    },
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupNoteRefRecursive({
            ...opts,
            extra: { idv2: true },
        });
    },
});
const ALL_TEST_CASES = [
    ...WITH_ABBR,
    ...WITH_VARIABLE,
    ...WITH_ASSET_PREFIX,
    ...WITH_ASSET_PREFIX_UNDEFINED,
    ...NOTE_REF_BASIC_WITH_REHYPE,
    ...NOTE_REF_RECURSIVE_BASIC_WITH_REHYPE,
    ...WITH_TITLE,
    ...NOTE_W_LINK_AND_SPACE,
    ...WITH_FOOTNOTES,
];
describe("MDUtils.proc", () => {
    test.each(ALL_TEST_CASES.map((ent) => [`${ent.dest}: ${ent.name}`, ent.testCase]))("%p", async (_key, testCase) => {
        await common_test_utils_1.runEngineTestV4(testCase.testFunc, {
            expect,
            createEngine: utils_2.createEngine,
            preSetupHook: testCase.preSetupHook,
        });
    });
});
//# sourceMappingURL=utils.spec.js.map