"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDUtilsV4 = void 0;
const common_all_1 = require("@dendronhq/common-all");
// @ts-ignore
const rehype_prism_1 = __importDefault(require("@mapbox/rehype-prism"));
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const rehype_autolink_headings_1 = __importDefault(require("rehype-autolink-headings"));
// @ts-ignore
const rehype_katex_1 = __importDefault(require("rehype-katex"));
const rehype_raw_1 = __importDefault(require("rehype-raw"));
const rehype_slug_1 = __importDefault(require("rehype-slug"));
const rehype_stringify_1 = __importDefault(require("rehype-stringify"));
const remark_1 = __importDefault(require("remark"));
// @ts-ignore
const remark_variables_1 = __importDefault(require("remark-variables"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const remark_math_1 = __importDefault(require("remark-math"));
const remark_parse_1 = __importDefault(require("remark-parse"));
const remark_rehype_1 = __importDefault(require("remark-rehype"));
const remark_stringify_1 = __importDefault(require("remark-stringify"));
const unified_1 = __importDefault(require("unified"));
const dendronPub_1 = require("./remark/dendronPub");
const noteRefs_1 = require("./remark/noteRefs");
const wikiLinks_1 = require("./remark/wikiLinks");
const types_1 = require("./types");
const remark_abbr_1 = __importDefault(require("remark-abbr"));
const noteRefsV2_1 = require("./remark/noteRefsV2");
const remark_footnotes_1 = __importDefault(require("remark-footnotes"));
const toString = require("mdast-util-to-string");
class MDUtilsV4 {
    static findIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            if (fn(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    static genMDMsg(msg) {
        return mdast_builder_1.root(mdast_builder_1.paragraph(mdast_builder_1.text(msg)));
    }
    static getDendronData(proc) {
        return proc.data("dendron");
    }
    static setDendronData(proc, data) {
        const _data = proc.data("dendron");
        return proc.data("dendron", { ..._data, ...data });
    }
    static getEngineFromProc(proc) {
        const engine = proc.data("engine");
        let error;
        if (lodash_1.default.isUndefined(engine) || lodash_1.default.isNull(engine)) {
            error = new common_all_1.DendronError({ msg: "engine not defined" });
        }
        return {
            error,
            engine,
        };
    }
    static getNoteRefLvl(proc) {
        return proc.data("noteRefLvl") || 0;
    }
    static setNoteRefLvl(proc, lvl) {
        return proc.data("noteRefLvl", lvl);
    }
    // @deprecate
    static isHeading(node, text, depth) {
        if (node.type !== "heading") {
            return false;
        }
        // wildcard is always true
        if (text === "*") {
            return true;
        }
        if (text) {
            var headingText = toString(node);
            return text.trim().toLowerCase() === headingText.trim().toLowerCase();
        }
        if (depth) {
            return node.depth <= depth;
        }
        return true;
    }
    static matchHeading(node, text, opts) {
        const { depth, slugger } = opts;
        if (node.type !== "heading") {
            return false;
        }
        // wildcard is always true
        if (text === "*") {
            return true;
        }
        if (text) {
            var headingText = toString(node);
            return text.trim().toLowerCase() === slugger.slug(headingText.trim());
        }
        if (depth) {
            return node.depth <= depth;
        }
        return true;
    }
    static remark() {
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .use(remark_frontmatter_1.default, ["yaml"])
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        return _proc;
    }
    static proc(opts) {
        const { engine } = opts;
        const errors = [];
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            //.use(remarkStringify)
            .data("errors", errors)
            .data("engine", engine)
            .use(remark_frontmatter_1.default, ["yaml"])
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        return _proc;
    }
    static procFull(opts) {
        var _a;
        const { dest, vault, fname, config } = opts;
        let proc = this.proc(opts);
        if (vault && fname) {
            const engine = MDUtilsV4.getEngineFromProc(proc).engine;
            const note = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                fname,
                notes: engine.notes,
                vault,
            });
            const fm = {
                ...note === null || note === void 0 ? void 0 : note.custom,
                title: note === null || note === void 0 ? void 0 : note.title,
            };
            proc = proc.data("fm", fm);
        }
        proc = proc
            .data("dendron", { dest, vault, fname, config })
            //.use(extract, { name: "fm" })
            .use(remark_abbr_1.default)
            .use(remark_variables_1.default)
            .use(remark_footnotes_1.default)
            .use(wikiLinks_1.wikiLinks, opts.wikiLinksOpts)
            .use(noteRefsV2_1.noteRefsV2, {
            ...opts.noteRefOpts,
            wikiLinkOpts: opts.wikiLinksOpts,
        })
            .use(noteRefs_1.noteRefs, { ...opts.noteRefOpts, wikiLinkOpts: opts.wikiLinksOpts });
        if ((_a = opts.mathOpts) === null || _a === void 0 ? void 0 : _a.katex) {
            proc = proc.use(remark_math_1.default);
        }
        // MD_DENDRON, convert back to itself, no need for transformations
        if (dest !== types_1.DendronASTDest.MD_DENDRON) {
            proc = proc.use(dendronPub_1.dendronPub, {
                ...opts.publishOpts,
                wikiLinkOpts: opts.wikiLinksOpts,
            });
        }
        proc = proc.data("procFull", proc().freeze());
        return proc;
    }
    static procRemark(opts) {
        const { proc } = opts;
        let _proc = proc || this.remark();
        return _proc.use(remark_parse_1.default, { gfm: true }).use(remark_stringify_1.default);
    }
    static procRehype(opts) {
        const { proc, mdPlugins } = lodash_1.default.defaults(opts, { mdPlugins: [] });
        let _proc = proc || unified_1.default().use(remark_parse_1.default, { gfm: true });
        mdPlugins.forEach((p) => {
            _proc = _proc.use(p);
        });
        _proc = _proc
            .use(remark_rehype_1.default, { allowDangerousHtml: true })
            .use(rehype_prism_1.default, { ignoreMissing: true })
            .use(rehype_raw_1.default)
            .use(rehype_slug_1.default)
            .use(rehype_autolink_headings_1.default, {
            properties: {
                "aria-hidden": "true",
                class: "anchor-heading",
            },
            content: {
                type: "element",
                tagName: "svg",
                properties: {
                    "aria-hidden": "true",
                    viewBox: "0 0 16 16",
                },
                children: [
                    {
                        type: "element",
                        tagName: "use",
                        properties: {
                            "xlink:href": "#svg-link",
                        },
                    },
                ],
            },
        });
        if (opts.mathjax) {
            _proc = _proc.use(rehype_katex_1.default);
        }
        return _proc.use(rehype_stringify_1.default);
    }
}
exports.MDUtilsV4 = MDUtilsV4;
//# sourceMappingURL=utils.js.map