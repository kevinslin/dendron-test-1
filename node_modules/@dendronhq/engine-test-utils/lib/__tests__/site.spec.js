"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const engine_server_1 = require("@dendronhq/engine-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("../config");
const engine_1 = require("../engine");
const basicSetup = (preSetupHook) => ({
    createEngine: engine_server_1.createEngine,
    expect,
    preSetupHook: async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        if (preSetupHook) {
            await preSetupHook(opts);
        }
    },
});
const dupNote = (vault) => {
    return {
        duplicateNoteBehavior: {
            action: common_all_1.DuplicateNoteAction.USE_VAULT,
            payload: {
                vault,
            },
        },
    };
};
const checkNotes = (opts) => {
    const { noMatch, filteredNotes, engineNotes } = opts;
    const notesActual = lodash_1.default.sortBy(lodash_1.default.values(opts.filteredNotes), "id");
    const notesExpected = lodash_1.default.map(opts.match, (opts) => {
        let note = { ...engineNotes[opts.id] };
        note = { ...note, ...opts };
        return note;
    });
    expect(notesActual).toEqual(lodash_1.default.sortBy(notesExpected, "id"));
    if (noMatch) {
        expect(lodash_1.default.every(noMatch, ({ id }) => {
            return !lodash_1.default.has(filteredNotes, id);
        })).toBeTruthy();
    }
};
describe("SiteUtils", () => {
    let siteRootDir;
    beforeEach(() => {
        siteRootDir = common_server_1.tmpDir().name;
    });
    describe("gen", () => {
        test("write stub", async () => {
            await engine_1.runEngineTestV5(async ({ engine, vaults, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo", "foobar"],
                        siteRootDir,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes, domains } = await engine_server_1.SiteUtils.filterByConfig({
                    engine,
                    config,
                });
                expect(domains.length).toEqual(2);
                expect(lodash_1.default.size(notes)).toEqual(4);
                const vpath = common_server_1.vault2Path({ wsRoot, vault: vaults[0] });
                const vaultNotes = fs_extra_1.default.readdirSync(vpath, { encoding: "utf8" });
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: vaultNotes.join(" "),
                    match: ["foobar.md"],
                })).toBeTruthy();
            }, {
                ...basicSetup(async (opts) => {
                    const wsRoot = opts.wsRoot;
                    const vault = opts.vaults[0];
                    await common_test_utils_1.NoteTestUtilsV4.createNote({
                        fname: "foobar.ch1",
                        vault,
                        wsRoot,
                    });
                }),
            });
        });
        test("no write stub", async () => {
            await engine_1.runEngineTestV5(async ({ engine, vaults, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo", "foobar"],
                        siteRootDir,
                        writeStubs: false,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                expect(lodash_1.default.size(notes)).toEqual(4);
                const vpath = common_server_1.vault2Path({ wsRoot, vault: vaults[0] });
                const vaultNotes = fs_extra_1.default.readdirSync(vpath, { encoding: "utf8" });
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: vaultNotes.join(" "),
                    nomatch: ["foobar.md"],
                })).toBeTruthy();
            }, {
                ...basicSetup(async (opts) => {
                    const wsRoot = opts.wsRoot;
                    const vault = opts.vaults[0];
                    await common_test_utils_1.NoteTestUtilsV4.createNote({
                        fname: "foobar.ch1",
                        vault,
                        wsRoot,
                    });
                }),
            });
        });
    });
    describe("per note config", () => {
        test("blacklist note", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo"],
                        siteRootDir,
                        usePrettyRefs: true,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                expect(lodash_1.default.size(notes)).toEqual(1);
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [{ id: "foo", parent: null, children: [] }],
                    noMatch: [{ id: "foo.ch1" }],
                });
                expect(notes["foo"].children).toEqual([]);
            }, {
                ...basicSetup(async (opts) => {
                    const wsRoot = opts.wsRoot;
                    const vault = opts.vaults[0];
                    return common_test_utils_1.NoteTestUtilsV4.modifyNoteByPath({ fname: "foo.ch1", wsRoot, vault }, (note) => {
                        note.custom = { published: false };
                        return note;
                    });
                }),
            });
        });
        test("nav_exclude", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo"],
                        siteRootDir,
                        usePrettyRefs: true,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                expect(lodash_1.default.size(notes)).toEqual(2);
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [{ id: "foo", parent: null }, { id: "foo.ch1" }],
                });
            }, {
                ...basicSetup(async (opts) => {
                    const wsRoot = opts.wsRoot;
                    const vault = opts.vaults[0];
                    return common_test_utils_1.NoteTestUtilsV4.modifyNoteByPath({ fname: "foo.ch1", wsRoot, vault }, (note) => {
                        note.custom = { nav_exclude: true };
                        return note;
                    });
                }),
            });
        });
    });
    describe("per hierarchy config", () => {
        let siteRootDir;
        beforeEach(() => {
            siteRootDir = common_server_1.tmpDir().name;
        });
        test("root, publish all with dup", async () => {
            await engine_1.runEngineTestV5(async ({ engine, vaults, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["root"],
                        siteRootDir,
                        ...dupNote(vaults[0]),
                        config: {
                            root: {
                                publishByDefault: true,
                            },
                        },
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes, domains } = await engine_server_1.SiteUtils.filterByConfig({
                    engine,
                    config,
                });
                const root = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "root",
                    notes: engine.notes,
                    vault: vaults[0],
                });
                expect(domains.length).toEqual(3);
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [
                        { id: root.id },
                        { id: "foo" },
                        { id: "bar" },
                        { id: "foo.ch1" },
                    ],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: async (opts) => {
                    await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
                },
            });
        });
        test("root, publish none with dup", async () => {
            await engine_1.runEngineTestV5(async ({ engine, vaults, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["root"],
                        siteRootDir,
                        ...dupNote(vaults[0]),
                        config: {
                            root: {
                                publishByDefault: false,
                            },
                        },
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: async (opts) => {
                    await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
                },
            });
        });
        test("one hiearchy", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo"],
                        siteRootDir,
                        usePrettyRefs: true,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [{ id: "foo", parent: null }, { id: "foo.ch1" }],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
            });
        });
        test("mult hiearchy", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo", "bar"],
                        siteRootDir,
                        usePrettyRefs: true,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [
                        { id: "foo", parent: null },
                        { id: "foo.ch1" },
                        { id: "bar", parent: null },
                    ],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
            });
        });
        // TODO: fix
        test.skip("mult hiearchy, diff publishByDefault", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot, vaults }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["foo", "bar"],
                        siteRootDir,
                        ...dupNote(vaults[0]),
                        config: {
                            foo: {
                                publishByDefault: {
                                    vault1: true,
                                    vault2: false,
                                },
                            },
                        },
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                expect(notes).toMatchSnapshot();
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [
                        { id: "foo", parent: null },
                        { id: "foo.ch1" },
                        { id: "bar", parent: null },
                    ],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: async (opts) => {
                    await common_test_utils_1.ENGINE_HOOKS_MULTI.setupBasicMulti(opts);
                    await common_test_utils_1.NoteTestUtilsV4.createNote({
                        fname: "foo.ch2",
                        vault: opts.vaults[1],
                        wsRoot: opts.wsRoot,
                    });
                },
            });
        });
        test("skip levels", async () => {
            await engine_1.runEngineTestV5(async ({ engine, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    config.site = {
                        siteHierarchies: ["daily"],
                        siteRootDir,
                    };
                    return config;
                }, {
                    wsRoot,
                });
                const { notes } = await engine_server_1.SiteUtils.filterByConfig({ engine, config });
                expect(lodash_1.default.values(notes).map((ent) => ent.fname)).toEqual([
                    "daily",
                    "daily.journal",
                    "daily.journal.2020.07.05.two",
                    "daily.journal.2020.07.01.one",
                ]);
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: async (opts) => {
                    await common_test_utils_1.ENGINE_HOOKS.setupJournals(opts);
                    const { wsRoot, vaults } = opts;
                    const vault = vaults[0];
                    await common_test_utils_1.NoteTestUtilsV4.modifyNoteByPath({ wsRoot, vault, fname: "daily.journal" }, (note) => {
                        note.custom.skipLevels = 3;
                        return note;
                    });
                    console.log(wsRoot, vault);
                },
            });
        });
    });
    describe("per vault config", () => {
        let siteRootDir;
        beforeEach(() => {
            siteRootDir = common_server_1.tmpDir().name;
        });
        test("blacklist vault", async () => {
            await engine_1.runEngineTestV5(async ({ engine, vaults, wsRoot }) => {
                const config = config_1.ConfigUtils.withConfig((config) => {
                    const bvault = config.vaults.find((ent) => ent.fsPath === "vault2");
                    bvault.visibility = common_all_1.DVaultVisibility.PRIVATE;
                    const sconfig = {
                        siteHierarchies: ["root"],
                        siteRootDir,
                        ...dupNote(vaults[0]),
                        config: {
                            root: {
                                publishByDefault: true,
                            },
                        },
                    };
                    config.site = sconfig;
                    return config;
                }, { wsRoot });
                const { notes, domains } = await engine_server_1.SiteUtils.filterByConfig({
                    engine,
                    config,
                });
                const root = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                    fname: "root",
                    notes: engine.notes,
                    vault: vaults[0],
                });
                expect(domains.length).toEqual(2);
                checkNotes({
                    filteredNotes: notes,
                    engineNotes: engine.notes,
                    match: [{ id: root.id }, { id: "foo" }, { id: "foo.ch1" }],
                });
            }, {
                createEngine: engine_server_1.createEngine,
                expect,
                preSetupHook: async (opts) => {
                    await common_test_utils_1.ENGINE_HOOKS_MULTI.setupBasicMulti(opts);
                },
            });
        });
    });
});
//# sourceMappingURL=site.spec.js.map