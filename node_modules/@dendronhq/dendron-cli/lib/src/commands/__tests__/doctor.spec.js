"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_server_1 = require("@dendronhq/common-server");
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const engine_server_1 = require("@dendronhq/engine-server");
const path_1 = __importDefault(require("path"));
const doctor_1 = require("../doctor");
const setupBasic = async (opts) => {
    const { wsRoot, vaults } = opts;
    await common_test_utils_1.NoteTestUtilsV4.createNote({
        wsRoot,
        vault: vaults[0],
        fname: "foo",
        body: [`# Foo Header`, `## Foo Content`].join("\n"),
    });
    await common_test_utils_1.NoteTestUtilsV4.createNote({
        wsRoot,
        vault: vaults[0],
        fname: "bar",
        body: [`# Bar Header`, `## Bar Content`].join("\n"),
    });
};
const runDoctor = (opts) => {
    const cmd = new doctor_1.DoctorCLICommand();
    return cmd.execute({
        exit: false,
        ...opts,
    });
};
// const setupNoFM= async (opts: WorkspaceOpts) => {
//   const { wsRoot, vaults } = opts;
//   const vpath = path.join(wsRoot, vaults[0].fsPath)
//   fs.writeFileSync( path.join(vpath, "foo.md"), "Foo Body", {encoding: "utf8"})
//   fs.writeFileSync( path.join(vpath, "bar.md"), "Bar Body", {encoding: "utf8"})
// };
describe(doctor_1.DoctorActions.HI_TO_H2, () => {
    const action = doctor_1.DoctorActions.HI_TO_H2;
    test("basic", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot, vaults }) => {
            const vault = vaults[0];
            await runDoctor({
                wsRoot,
                engine,
                action,
            });
            const names = ["Foo", "Bar"];
            await Promise.all(names.map(async (nm) => {
                const fpath = path_1.default.join(wsRoot, vault.fsPath, `${nm.toLowerCase()}.md`);
                const note = common_server_1.file2Note(fpath, vault);
                expect(note).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: note.body,
                    match: [`## ${nm} Header`],
                })).toBeTruthy();
            }));
        }, {
            createEngine: engine_server_1.createEngine,
            expect,
            preSetupHook: setupBasic,
        });
    });
    test("dry run", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot, vaults }) => {
            const vault = vaults[0];
            await runDoctor({
                wsRoot,
                engine,
                action,
                dryRun: true,
            });
            const names = ["Foo", "Bar"];
            await Promise.all(names.map(async (nm) => {
                const fpath = path_1.default.join(wsRoot, vault.fsPath, `${nm.toLowerCase()}.md`);
                const note = common_server_1.file2Note(fpath, vault);
                expect(note).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: note.body,
                    nomatch: [`## ${nm} Header`],
                })).toBeTruthy();
            }));
        }, {
            createEngine: engine_server_1.createEngine,
            expect,
            preSetupHook: setupBasic,
        });
    });
});
describe("H1_TO_TITLE", () => {
    const action = doctor_1.DoctorActions.H1_TO_TITLE;
    test("basic", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, wsRoot, vaults }) => {
            const vault = vaults[0];
            await runDoctor({
                wsRoot,
                engine,
                action,
            });
            const names = ["Foo", "Bar"];
            await Promise.all(names.map(async (nm) => {
                const fpath = path_1.default.join(wsRoot, vault.fsPath, `${nm.toLowerCase()}.md`);
                const note = common_server_1.file2Note(fpath, vault);
                expect(note).toMatchSnapshot();
                expect(note.title).toEqual(`${nm} Header`);
            }));
        }, {
            createEngine: engine_server_1.createEngine,
            expect,
            preSetupHook: setupBasic,
        });
    });
});
// describe.only(DoctorActions.FIX_FM, () => {
//   const action = DoctorActions.FIX_FM;
//   test("basic", async () => {
//     await runEngineTestV4(
//       async ({ engine, wsRoot, vaults }) => {
//         const vault = vaults[0];
//         const cmd = new DoctorCLICommand();
//         await cmd.execute({
//           wsRoot,
//           engine,
//           action,
//         });
//         const names = ["Foo", "Bar"];
//         await Promise.all(
//           names.map(async (nm) => {
//             const fpath = path.join(
//               wsRoot,
//               vault.fsPath,
//               `${nm.toLowerCase()}.md`
//             );
//             const note = file2Note(fpath, vault);
//             expect(note).toMatchSnapshot();
//           })
//         );
//       },
//       {
//         createEngine,
//         expect,
//         preSetupHook: setupNoFM,
//       }
//     );
//   });
// });
//# sourceMappingURL=doctor.spec.js.map