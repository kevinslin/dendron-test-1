"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DoctorCLICommand = exports.DoctorActions = void 0;
const common_all_1 = require("@dendronhq/common-all");
const engine_server_1 = require("@dendronhq/engine-server");
// @ts-ignore
const async_throttle_1 = __importDefault(require("@jcoreio/async-throttle"));
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const utils_1 = require("./utils");
var DoctorActions;
(function (DoctorActions) {
    DoctorActions["H1_TO_TITLE"] = "h1ToTitle";
    DoctorActions["HI_TO_H2"] = "h1ToH2";
    DoctorActions["REMOVE_STUBS"] = "removeStubs";
    // FIX_FM = "fixFM"
})(DoctorActions = exports.DoctorActions || (exports.DoctorActions = {}));
class DoctorCLICommand extends base_1.CLICommand {
    constructor() {
        super({ name: "doctor", desc: "doctor helps you fix your notes" });
    }
    buildArgs(args) {
        super.buildArgs(args);
        utils_1.setupEngineArgs(args);
        args.option("actions", {
            describe: "what actions the doctor should take",
            type: "string",
            requiresArg: true,
            choices: Object.values(DoctorActions),
        });
        args.option("query", {
            describe: "run doctor over a query",
            type: "string",
        });
        args.option("limit", {
            describe: "limit num changes",
            type: "number",
        });
        args.option("dryRun", {
            describe: "dry run",
            type: "boolean",
        });
    }
    async enrichArgs(args) {
        const engineArgs = await utils_1.setupEngine(args);
        return { ...args, ...engineArgs };
    }
    async execute(opts) {
        const { action, engine, query, limit, dryRun, exit } = lodash_1.default.defaults(opts, {
            limit: 99999,
            exit: true,
        });
        const proc = engine_server_1.MDUtilsV4.procFull({
            dest: engine_server_1.DendronASTDest.MD_DENDRON,
            engine,
            mathOpts: { katex: true },
        });
        let notes = query
            ? engine.queryNotesSync({ qs: query }).data
            : lodash_1.default.values(engine.notes);
        notes = notes.filter((n) => !n.stub);
        this.L.info({ msg: "prep doctor", numResults: notes.length });
        let numChanges = 0;
        let engineWrite = dryRun
            ? () => { }
            : async_throttle_1.default(lodash_1.default.bind(engine.writeNote, engine), 300, {
                leading: true,
            });
        let engineDelete = dryRun
            ? () => { }
            : async_throttle_1.default(lodash_1.default.bind(engine.deleteNote, engine), 300, {
                leading: true,
            });
        let doctorAction;
        switch (action) {
            case DoctorActions.H1_TO_TITLE: {
                doctorAction = async (note) => {
                    let changes = [];
                    const newBody = await proc()
                        .use(engine_server_1.RemarkUtils.h1ToTitle(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        console.log(`doctor changing ${note.fname}`);
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.HI_TO_H2: {
                doctorAction = async (note) => {
                    let changes = [];
                    const newBody = await proc()
                        .use(engine_server_1.RemarkUtils.h1ToH2(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        console.log(`doctor changing ${note.fname}`);
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActions.REMOVE_STUBS: {
                doctorAction = async (note) => {
                    let changes = [];
                    if (lodash_1.default.trim(note.body) === "") {
                        changes.push({
                            status: "delete",
                            note,
                        });
                    }
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineDelete(note);
                        const vname = common_all_1.VaultUtils.getName(note.vault);
                        console.log(`doctor ${DoctorActions.REMOVE_STUBS} ${note.fname} ${vname}`);
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
        }
        await lodash_1.default.reduce(notes, async (accInner, note) => {
            await accInner;
            if (numChanges >= limit) {
                return;
            }
            this.L.debug({ msg: `processing ${note.fname}` });
            return doctorAction(note);
        }, Promise.resolve());
        console.log(`doctor fixed ${numChanges} notes`);
        this.L.info({ msg: "doctor done", numChanges });
        if (exit) {
            process.exit();
        }
        return;
    }
}
exports.DoctorCLICommand = DoctorCLICommand;
//# sourceMappingURL=doctor.js.map