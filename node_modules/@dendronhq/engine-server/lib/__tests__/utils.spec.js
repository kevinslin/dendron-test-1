"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../utils");
function createFileLink(data) {
    let cleanData = lodash_1.default.defaults(data, { type: "file" });
    return {
        from: {
            fname: "foo",
        },
        type: "ref",
        data: cleanData,
    };
}
describe("matchEmbedMarker", () => {
    test("basic", () => {
        // @ts-ignore
        expect(utils_1.matchRefMarker("<!--(([[class.mba.chapters.2]]))-->")[1]).toEqual("[[class.mba.chapters.2]]");
    });
});
describe("parseFileLink", () => {
    it("just file", () => {
        expect(utils_1.parseFileLink("[[foo]]")).toEqual(createFileLink());
    });
    it("one anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1")).toEqual(createFileLink({ anchorStart: "head1" }));
    });
    it("all parts", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#head2")).toEqual(createFileLink({ anchorStart: "head1", anchorEnd: "head2" }));
    });
    it("next anchor", () => {
        expect(utils_1.parseFileLink("[[foo]]#head1:#*")).toEqual(createFileLink({ anchorStart: "head1", anchorEnd: "*" }));
    });
});
describe("link2String", () => {
    test("file", () => {
        expect(utils_1.refLink2String({
            type: "ref",
            from: {
                fname: "foo",
            },
            data: {
                type: "file",
            },
        })).toEqual("[[foo]]");
    });
    it("one anchor", () => {
        expect(utils_1.refLink2String(createFileLink({ anchorStart: "head1" }))).toEqual("[[foo]]#head1");
    });
    it("all parts", () => {
        expect(utils_1.refLink2String(createFileLink({
            anchorEnd: "head2",
            anchorStart: "head1",
        }))).toEqual("[[foo]]#head1:#head2");
    });
    it("next anchor", () => {
        expect(utils_1.refLink2String(createFileLink({
            anchorEnd: "*",
            anchorStart: "head1",
        }))).toEqual("[[foo]]#head1:#*");
    });
});
describe("parseRef", () => {
    it("describe file ref without extension", () => {
        expect(utils_1.parseDendronRef("ref: [[foo]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]")).toEqual({
            direction: "to",
            link: createFileLink(),
        });
    });
    it("describe file ref with anchor", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1" }),
        });
    });
    it("describe file ref with anchor start and end", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({ anchorStart: "head1", anchorEnd: "head2" }),
        });
    });
    it("describe file ref with anchor start and end, start offset", () => {
        expect(utils_1.parseDendronRef("ref: [[foo.md]]#head1,1:#head2")).toEqual({
            direction: "to",
            link: createFileLink({
                anchorStart: "head1",
                anchorEnd: "head2",
                anchorStartOffset: 1,
            }),
        });
    });
});
describe("stripLocalOnlyTags", () => {
    it("basic", () => {
        const txt = `
- this is a bullet
    - this is a secret <!--LOCAL_ONLY_LINE-->
`;
        expect(lodash_1.default.trim(utils_1.stripLocalOnlyTags(txt))).toEqual("- this is a bullet");
    });
});
//# sourceMappingURL=utils.spec.js.map