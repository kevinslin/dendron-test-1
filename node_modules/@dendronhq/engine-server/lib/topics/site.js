"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SiteUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("../config");
const utils_1 = require("../utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const common_server_1 = require("@dendronhq/common-server");
const logger = common_server_1.createLogger();
class SiteUtils {
    static canPublish(opts) {
        const { note, config, vaults, wsRoot } = opts;
        // check if note is in index
        const domain = common_all_1.DNodeUtilsV2.domainName(note.fname);
        if (config.siteHierarchies[0] !== "root" &&
            config.siteHierarchies.indexOf(domain) < 0) {
            return false;
        }
        // check if note is note blocked
        const hconfig = this.getConfigForHierarchy({ config, noteOrName: note });
        return this.canPublishFiltered({ note, hconfig, vaults, wsRoot });
    }
    static canPublishFiltered(opts) {
        var _a, _b;
        const { note, hconfig, vaults, wsRoot } = opts;
        if (note.stub) {
            return true;
        }
        const noteVault = common_all_1.VaultUtils.matchVault({
            vault: note.vault,
            vaults,
            wsRoot,
        });
        common_all_1.assert(noteVault !== false, "noteVault should exist");
        const cNoteVault = noteVault;
        let publishByDefault = undefined;
        if (hconfig === null || hconfig === void 0 ? void 0 : hconfig.publishByDefault) {
            publishByDefault = lodash_1.default.isBoolean(hconfig.publishByDefault)
                ? hconfig.publishByDefault
                : hconfig.publishByDefault[common_all_1.VaultUtils.getName(cNoteVault)];
        }
        return !lodash_1.default.some([
            // not from private vault
            noteVault.visibility &&
                noteVault.visibility === common_all_1.DVaultVisibility.PRIVATE,
            // not blacklisted
            ((_a = note === null || note === void 0 ? void 0 : note.custom) === null || _a === void 0 ? void 0 : _a.published) === false,
            // not whitelisted
            !publishByDefault ? !((_b = note.custom) === null || _b === void 0 ? void 0 : _b.published) : false,
        ]);
    }
    static async copyAssets(opts) {
        const { wsRoot, vault, siteAssetsDir } = opts;
        const vaultAssetsDir = path_1.default.join(common_server_1.vault2Path({ wsRoot, vault }), "assets");
        if (fs_extra_1.default.existsSync(vaultAssetsDir)) {
            return fs_extra_1.default.copy(path_1.default.join(vaultAssetsDir), path_1.default.join(siteAssetsDir));
        }
        return;
    }
    static addSiteOnlyNotes(opts) {
        const { engine } = opts;
        const vaults = engine.vaultsv3;
        const note = common_all_1.NoteUtilsV2.create({
            vault: vaults[0],
            fname: "403",
            id: "403",
            title: "Your viewing an unpublished page",
            body: [
                "[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to a page that is not published.",
            ].join("\n"),
        });
        return [note];
    }
    static async filterByConfig(opts) {
        const { engine, config } = opts;
        const notes = lodash_1.default.clone(engine.notes);
        config.site = config_1.DConfig.cleanSiteConfig(config.site);
        const sconfig = config.site;
        const { siteHierarchies } = sconfig;
        logger.info({ ctx: "filterByConfig", config });
        let domains = [];
        // TODO: return domains from here
        const hiearchiesToPublish = await Promise.all(siteHierarchies.map(async (domain, idx) => {
            const out = await SiteUtils.filterByHiearchy({
                domain,
                config,
                engine,
                navOrder: idx,
            });
            if (lodash_1.default.isUndefined(out)) {
                return {};
            }
            domains.push(out.domain);
            return out.notes;
        }));
        // if single hiearchy, domain includes all immediate children
        if (siteHierarchies.length === 1 && domains.length === 1) {
            const rootDomain = domains[0];
            domains = domains.concat(rootDomain.children.map((id) => notes[id]));
        }
        logger.info({
            ctx: "filterByConfig",
            domains: domains.map((ent) => ent.fname),
        });
        return {
            notes: lodash_1.default.reduce(hiearchiesToPublish, (ent, acc) => {
                return lodash_1.default.merge(acc, ent);
            }, {}),
            domains,
        };
    }
    static async filterByHiearchy(opts) {
        const { domain, engine, navOrder, config } = opts;
        logger.info({ ctx: "filterByHiearchy", domain });
        const sconfig = config.site;
        let hConfig = this.getConfigForHierarchy({
            config: sconfig,
            noteOrName: domain,
        });
        const dupBehavior = sconfig.duplicateNoteBehavior;
        const notesForHiearchy = lodash_1.default.clone(engine.notes);
        // get the domain note
        let notes = common_all_1.NoteUtilsV2.getNotesByFname({
            fname: domain,
            notes: notesForHiearchy,
        }).filter((note) => SiteUtils.canPublishFiltered({
            note,
            hconfig: hConfig,
            vaults: config.vaults,
            wsRoot: engine.wsRoot,
        }));
        logger.info({
            ctx: "filterByHiearchy",
            msg: "post-filter",
            hConfig,
            filteredNotes: notes.map((ent) => ent.fname),
        });
        let domainNote;
        if (notes.length > 1) {
            if (dupBehavior) {
                const vault = dupBehavior.payload.vault;
                const maybeDomainNote = notes.filter((n) => common_all_1.VaultUtils.isEqual(n.vault, vault, engine.wsRoot));
                if (maybeDomainNote.length < 1) {
                    logger.error({
                        ctx: "filterByHiearchy",
                        msg: "dup-resolution: no note found",
                        vault,
                    });
                    return;
                }
                domainNote = maybeDomainNote[0];
                // merge children
                domainNote.children = lodash_1.default.uniq(notes.flatMap((ent) => ent.children));
                // update parents
                domainNote.children.map((id) => (notesForHiearchy[id].parent = domainNote.id));
                logger.info({
                    ctx: "filterByHiearchy",
                    msg: "dup-resolution: resolving dup",
                    parent: domainNote.id,
                    children: domainNote.children,
                });
            }
            else {
                throw new common_all_1.DendronError({ msg: `mult notes found for ${domain}` });
            }
        }
        else if (notes.length < 1) {
            logger.error({ ctx: "filterByHiearchy", msg: "note not found", domain });
            // TODO: add warning
            return;
        }
        else {
            domainNote = { ...notes[0] };
        }
        if (!domainNote.custom) {
            domainNote.custom = {};
        }
        // set domain note settings
        domainNote.custom.nav_order = navOrder;
        domainNote.parent = null;
        if (domainNote.fname === sconfig.siteIndex) {
            domainNote.custom.permalink = "/";
        }
        logger.info({ ctx: "filterByHiearchy", domainNote });
        const out = {};
        const processQ = [domainNote];
        logger.info({ ctx: "filterByHiearchy", domainNote: domainNote.fname });
        while (!lodash_1.default.isEmpty(processQ)) {
            const note = processQ.pop();
            const maybeNote = SiteUtils.filterByNote({ note, hConfig });
            if (maybeNote) {
                if (sconfig.writeStubs && maybeNote.stub) {
                    maybeNote.stub = false;
                    await engine.writeNote(note);
                }
                const siteFM = maybeNote.custom || {};
                let children = maybeNote.children.map((id) => notesForHiearchy[id]);
                if (siteFM.skipLevels) {
                    let acc = 0;
                    while (acc !== siteFM.skipLevels) {
                        children = children.flatMap((ent) => ent.children.map((id) => notesForHiearchy[id]));
                        acc += 1;
                    }
                    maybeNote.children = children.map((ent) => ent.id);
                    children.forEach((ent) => (ent.parent = maybeNote.id));
                }
                children = lodash_1.default.filter(children, (note) => SiteUtils.canPublishFiltered({
                    note,
                    hconfig: hConfig,
                    vaults: config.vaults,
                    wsRoot: engine.wsRoot,
                }));
                children.forEach((n) => processQ.push(n));
                // updated children
                out[maybeNote.id] = {
                    ...maybeNote,
                    children: children.map((ent) => ent.id),
                };
            }
        }
        return { notes: out, domain: domainNote };
    }
    static filterByNote(opts) {
        var _a;
        const { note, hConfig } = opts;
        // apply custom frontmatter if exist
        (_a = hConfig.customFrontmatter) === null || _a === void 0 ? void 0 : _a.forEach((fm) => {
            const { key, value } = fm;
            // @ts-ignore
            meta[key] = value;
        });
        if (hConfig.noindexByDefault && !lodash_1.default.has(note, "custom.noindex")) {
            lodash_1.default.set(note, "custom.noindex", true);
        }
        // remove site-only stuff
        return {
            ...note,
            body: utils_1.stripLocalOnlyTags(note.body),
        };
    }
    static getConfigForHierarchy(opts) {
        const { config, noteOrName } = opts;
        const fname = lodash_1.default.isString(noteOrName) ? noteOrName : noteOrName.fname;
        const domain = common_all_1.DNodeUtilsV2.domainName(fname);
        const siteConfig = config;
        // get config
        let rConfig = lodash_1.default.defaults(lodash_1.default.get(siteConfig.config, "root", {
            publishByDefault: true,
            noindexByDefault: false,
            customFrontmatter: [],
        }));
        let hConfig = lodash_1.default.defaults(lodash_1.default.get(siteConfig.config, domain), rConfig);
        return hConfig;
    }
    static getDomains(opts) {
        const { notes, config } = opts;
        if (config.siteHierarchies.length === 1) {
            const fname = config.siteHierarchies[0];
            const rootNotes = common_all_1.NoteUtilsV2.getNotesByFname({ fname, notes });
            return [rootNotes[0]].concat(rootNotes[0].children.map((ent) => notes[ent]));
        }
        else {
            return lodash_1.default.filter(lodash_1.default.values(notes), { parent: null });
        }
    }
}
exports.SiteUtils = SiteUtils;
//# sourceMappingURL=site.js.map