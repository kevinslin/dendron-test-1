"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.noteRefsV2 = exports.convertNoteRefASTV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const utils_1 = require("../../utils");
const types_1 = require("../types");
const utils_2 = require("../utils");
const utils_3 = require("./utils");
const LINK_REGEX = /^\!\[\[(.+?)\]\]/;
const plugin = function (opts) {
    attachParser(this);
    if (this.Compiler != null) {
        attachCompiler(this, opts);
    }
};
exports.noteRefsV2 = plugin;
function attachParser(proc) {
    function locator(value, fromIndex) {
        return value.indexOf("![[", fromIndex);
    }
    function inlineTokenizer(eat, value) {
        const match = LINK_REGEX.exec(value);
        if (match) {
            const linkMatch = match[1].trim();
            const link = utils_1.parseFileLinkV2(linkMatch);
            const { value } = utils_3.LinkUtils.parseLink(linkMatch);
            return eat(match[0])({
                type: "refLinkV2",
                value,
                data: {
                    link,
                },
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.refLinkV2 = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "refLinkV2");
    return Parser;
}
function attachCompiler(proc, opts) {
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    const copts = lodash_1.default.defaults(opts || {}, {});
    const { dest } = utils_2.MDUtilsV4.getDendronData(proc);
    if (visitors) {
        visitors.refLinkV2 = function (node) {
            const ndata = node.data;
            if (dest === types_1.DendronASTDest.MD_DENDRON) {
                const { fname, alias } = ndata.link.from;
                const { anchorStart, anchorStartOffset, anchorEnd } = ndata.link.data;
                let link = alias ? `${alias}|${fname}` : fname;
                let suffix = "";
                if (anchorStart) {
                    suffix += `#${anchorStart}`;
                }
                if (anchorStartOffset) {
                    suffix += `,${anchorStartOffset}`;
                }
                if (anchorEnd) {
                    suffix += `:#${anchorEnd}`;
                }
                return `![[${link}${suffix}]]`;
            }
            const { error, data } = convertNoteRef({
                link: ndata.link,
                proc,
                compilerOpts: copts,
            });
            if (error) {
                return `ERROR converting ref: ${error.msg}`;
            }
            return data;
        };
    }
}
const MAX_REF_LVL = 3;
/**
 * Look at links and do initial pass
 */
function convertNoteRef(opts) {
    let data;
    let errors = [];
    const { link, proc, compilerOpts } = opts;
    const refLvl = utils_2.MDUtilsV4.getNoteRefLvl(proc());
    const { dest, vault } = utils_2.MDUtilsV4.getDendronData(proc);
    if (!vault) {
        return { error: new common_all_1.DendronError({ msg: "no vault specified" }), data: "" };
    }
    let { prettyRefs, wikiLinkOpts } = compilerOpts;
    if (!prettyRefs &&
        lodash_1.default.includes([types_1.DendronASTDest.HTML, types_1.DendronASTDest.MD_ENHANCED_PREVIEW], dest)) {
        prettyRefs = true;
    }
    if (refLvl >= MAX_REF_LVL) {
        return {
            error: new common_all_1.DendronError({ msg: "too many nested note refs" }),
            data,
        };
    }
    const { error, engine } = utils_2.MDUtilsV4.getEngineFromProc(proc);
    let noteRefs = [];
    if (link.from.fname.endsWith("*")) {
        const resp = engine.queryNotesSync({ qs: link.from.fname, vault });
        const out = lodash_1.default.filter(resp.data, (ent) => common_all_1.DUtils.minimatch(ent.fname, link.from.fname));
        noteRefs = lodash_1.default.sortBy(out.map((ent) => common_all_1.NoteUtilsV2.toNoteLoc(ent)), "fname");
    }
    else {
        noteRefs.push(link.from);
    }
    const out = noteRefs.map((ref) => {
        const fname = ref.fname;
        const alias = ref.alias;
        // TODO: find first unit with path
        const npath = common_all_1.DNodeUtilsV2.getFullPath({
            wsRoot: engine.wsRoot,
            vault,
            basename: fname + ".md",
        });
        try {
            const note = common_server_1.file2Note(npath, vault);
            const body = note.body;
            // let noteRefProc = proc();
            // MDUtilsV4.setDendronData(proc, {overrides: {insertTitle: false}});
            const { error, data } = convertNoteRefHelper({
                body,
                link,
                refLvl: refLvl + 1,
                proc: utils_2.MDUtilsV4.setDendronData(proc(), {
                    overrides: { insertTitle: false },
                }),
                //proc,
                compilerOpts,
            });
            if (error) {
                errors.push(error);
            }
            if (prettyRefs) {
                let suffix = "";
                let href = fname;
                if (wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.useId) {
                    const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                        fname,
                        notes: engine.notes,
                        vault,
                    });
                    if (!maybeNote) {
                        return `error with ${ref}`;
                    }
                    href = maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.id;
                }
                if (dest === types_1.DendronASTDest.HTML) {
                    const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                        fname,
                        notes: engine.notes,
                        vault,
                    });
                    suffix = ".html";
                    if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.custom.permalink) === "/") {
                        href = "";
                        suffix = "";
                    }
                }
                if (dest === types_1.DendronASTDest.MD_ENHANCED_PREVIEW) {
                    suffix = ".md";
                }
                const link = `"${(wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.prefix) || ""}${href}${suffix}"`;
                return renderPretty({
                    content: data,
                    title: alias || fname || "no title",
                    link,
                });
            }
            else {
                return data;
            }
        }
        catch (err) {
            const msg = `error reading file, ${npath}`;
            errors.push(new common_all_1.DendronError({ msg }));
            return msg;
        }
    });
    return { error, data: out.join("\n") };
}
function convertNoteRefASTV2(opts) {
    let errors = [];
    const { link, proc, compilerOpts } = opts;
    const refLvl = utils_2.MDUtilsV4.getNoteRefLvl(proc());
    const { dest, vault } = utils_2.MDUtilsV4.getDendronData(proc);
    if (!vault) {
        return { error: new common_all_1.DendronError({ msg: "no vault specified" }), data: [] };
    }
    let { prettyRefs, wikiLinkOpts } = compilerOpts;
    if (!prettyRefs &&
        lodash_1.default.includes([types_1.DendronASTDest.HTML, types_1.DendronASTDest.MD_ENHANCED_PREVIEW], dest)) {
        prettyRefs = true;
    }
    if (refLvl >= MAX_REF_LVL) {
        return {
            error: new common_all_1.DendronError({ msg: "too many nested note refs" }),
            data: [utils_2.MDUtilsV4.genMDMsg("too many nested note refs")],
        };
    }
    const { error, engine } = utils_2.MDUtilsV4.getEngineFromProc(proc);
    let noteRefs = [];
    if (link.from.fname.endsWith("*")) {
        const resp = engine.queryNotesSync({ qs: link.from.fname, vault });
        const out = lodash_1.default.filter(resp.data, (ent) => common_all_1.DUtils.minimatch(ent.fname, link.from.fname));
        noteRefs = lodash_1.default.sortBy(out.map((ent) => common_all_1.NoteUtilsV2.toNoteLoc(ent)), "fname");
    }
    else {
        noteRefs.push(link.from);
    }
    const out = noteRefs.map((ref) => {
        const fname = ref.fname;
        const alias = ref.alias;
        // TODO: find first unit with path
        const npath = common_all_1.DNodeUtilsV2.getFullPath({
            wsRoot: engine.wsRoot,
            vault,
            basename: fname + ".md",
        });
        try {
            const note = common_server_1.file2Note(npath, vault);
            const body = note.body;
            const { error, data } = convertNoteRefHelperAST({
                body,
                link,
                refLvl: refLvl + 1,
                proc,
                compilerOpts,
            });
            if (error) {
                errors.push(error);
            }
            if (prettyRefs) {
                let suffix = "";
                let href = fname;
                if (wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.useId) {
                    const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                        fname,
                        notes: engine.notes,
                        vault,
                    });
                    if (!maybeNote) {
                        throw Error("error with ref");
                        //return `error with ${ref}`;
                    }
                    href = maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.id;
                }
                if (dest === types_1.DendronASTDest.HTML) {
                    const maybeNote = common_all_1.NoteUtilsV2.getNoteByFnameV4({
                        fname,
                        notes: engine.notes,
                        vault,
                    });
                    suffix = ".html";
                    if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.custom.permalink) === "/") {
                        href = "";
                        suffix = "";
                    }
                }
                if (dest === types_1.DendronASTDest.MD_ENHANCED_PREVIEW) {
                    suffix = ".md";
                }
                const link = `"${(wikiLinkOpts === null || wikiLinkOpts === void 0 ? void 0 : wikiLinkOpts.prefix) || ""}${href}${suffix}"`;
                return renderPrettyAST({
                    content: data,
                    title: alias || fname || "no title",
                    link,
                });
            }
            else {
                return mdast_builder_1.paragraph(data);
            }
        }
        catch (err) {
            const msg = `error reading file, ${npath}`;
            errors.push(new common_all_1.DendronError({ msg }));
            throw Error(msg);
            // return msg;
        }
    });
    return { error, data: out };
}
exports.convertNoteRefASTV2 = convertNoteRefASTV2;
function convertNoteRefHelperAST(opts) {
    const { body, proc, refLvl, link } = opts;
    const noteRefProc = proc();
    utils_2.MDUtilsV4.setNoteRefLvl(noteRefProc, refLvl);
    const bodyAST = noteRefProc.parse(body);
    const { anchorStart, anchorEnd, anchorStartOffset } = lodash_1.default.defaults(link.data, {
        anchorStartOffset: 0,
    });
    // TODO: can i just strip frontmatter when reading?
    let anchorStartIndex = bodyAST.children[0].type === "yaml" ? 1 : 0;
    let anchorEndIndex = bodyAST.children.length;
    const slugger = common_all_1.getSlugger();
    if (anchorStart) {
        anchorStartIndex = findHeader({
            nodes: bodyAST.children,
            match: anchorStart,
            slugger,
        });
        if (anchorStartIndex < 0) {
            const data = utils_2.MDUtilsV4.genMDMsg(`Start anchor ${anchorStart} not found`);
            return { data, error: null };
        }
    }
    if (anchorEnd) {
        anchorEndIndex = findHeader({
            nodes: bodyAST.children.slice(anchorStartIndex + 1),
            match: anchorEnd,
            slugger,
        });
        if (anchorEndIndex < 0) {
            const data = utils_2.MDUtilsV4.genMDMsg(`end anchor ${anchorEnd} not found`);
            return { data, error: null };
        }
        anchorEndIndex += anchorStartIndex + 1;
    }
    // slice of interested range
    try {
        let out = mdast_builder_1.root(bodyAST.children.slice(anchorStartIndex + anchorStartOffset, anchorEndIndex));
        let _proc = proc.data("procFull");
        let out2 = _proc.stringify(out);
        out = _proc.parse(out2);
        return { error: null, data: out };
    }
    catch (err) {
        console.log("ERROR WITH RE in AST");
        console.log(JSON.stringify(err));
        return {
            error: new common_all_1.DendronError({
                msg: "error processing note ref",
                payload: err,
            }),
            data: utils_2.MDUtilsV4.genMDMsg("error processing ref"),
        };
    }
}
function convertNoteRefHelper(opts) {
    const { body, proc, refLvl, link } = opts;
    const noteRefProc = proc();
    utils_2.MDUtilsV4.setNoteRefLvl(noteRefProc, refLvl);
    const bodyAST = noteRefProc.parse(body);
    const { anchorStart, anchorEnd, anchorStartOffset } = link.data;
    // TODO: can i just strip frontmatter when reading?
    let anchorStartIndex = bodyAST.children[0].type === "yaml" ? 1 : 0;
    let anchorEndIndex = bodyAST.children.length;
    const slugger = common_all_1.getSlugger();
    if (anchorStart) {
        anchorStartIndex = findHeader({
            nodes: bodyAST.children,
            match: anchorStart,
            slugger,
        });
        if (anchorStartIndex < 0) {
            return { data: `Start anchor ${anchorStart} not found`, error: null };
        }
    }
    if (anchorEnd) {
        anchorEndIndex = findHeader({
            nodes: bodyAST.children.slice(anchorStartIndex + 1),
            match: anchorEnd,
            slugger,
        });
        if (anchorEndIndex < 0) {
            return { data: `end anchor ${anchorEnd} not found`, error: null };
        }
        anchorEndIndex += anchorStartIndex + 1;
    }
    // slice of interested range
    try {
        bodyAST.children = bodyAST.children.slice(anchorStartIndex, anchorEndIndex);
        let out = noteRefProc
            .processSync(noteRefProc.stringify(bodyAST))
            .toString();
        if (anchorStartOffset) {
            out = out.split("\n").slice(anchorStartOffset).join("\n");
        }
        return { error: null, data: out };
    }
    catch (err) {
        console.log("ERROR WITH REF");
        console.log(JSON.stringify(err));
        return {
            error: new common_all_1.DendronError({
                msg: "error processing note ref",
                payload: err,
            }),
            data: "error processing ref",
        };
    }
}
function findHeader({ nodes, match, slugger, }) {
    const foundIndex = utils_2.MDUtilsV4.findIndex(nodes, function (node) {
        return utils_2.MDUtilsV4.matchHeading(node, match, { slugger });
    });
    return foundIndex;
}
function renderPretty(opts) {
    const { content, title, link } = opts;
    return `
  <div class="portal-container">
  <div class="portal-head">
  <div class="portal-backlink" >
  <div class="portal-title">From <span class="portal-text-title">${title}</span></div>
  <a href=${link} class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
  </div>
  </div>
  <div id="portal-parent-anchor" class="portal-parent" markdown="1">
  <div class="portal-parent-fader-top"></div>
  <div class="portal-parent-fader-bottom"></div>        
  
  ${lodash_1.default.trim(content)}
  
  </div>    
  </div>
  `;
}
function renderPrettyAST(opts) {
    const { content, title, link } = opts;
    const top = `<div class="portal-container">
  <div class="portal-head">
  <div class="portal-backlink" >
  <div class="portal-title">From <span class="portal-text-title">${title}</span></div>
  <a href=${link} class="portal-arrow">Go to text <span class="right-arrow">→</span></a>
  </div>
  </div>
  <div id="portal-parent-anchor" class="portal-parent" markdown="1">
  <div class="portal-parent-fader-top"></div>
  <div class="portal-parent-fader-bottom"></div>
  `;
    const bottom = `\n</div>    
  </div>`;
    return mdast_builder_1.paragraph([mdast_builder_1.html(top)].concat([content]).concat([mdast_builder_1.html(bottom)]));
}
//# sourceMappingURL=noteRefsV2.js.map