"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const dendronPub_1 = require("../dendronPub");
const noteRefs_1 = require("../noteRefs");
const utils_2 = require("./utils");
function proc(engine, dendron, opts) {
    return utils_1.MDUtilsV4.proc({ engine })
        .data("dendron", dendron)
        .use(noteRefs_1.noteRefs, opts);
}
describe("parse", () => {
    let engine;
    let dest;
    test("init", () => {
        const resp = proc(engine, { dest }).parse(`((ref: [[foo.md]]))`);
        expect(resp).toMatchSnapshot();
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("refLink");
    });
    test("init with inject", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, vaults }) => {
            let _proc = proc(engine, { dest, vault: vaults[0] }).use(dendronPub_1.dendronPub);
            const resp = _proc.parse(`((ref: [[foo.md]]))`);
            expect(resp).toMatchSnapshot();
            const resp2 = _proc.runSync(resp);
            expect(resp2).toMatchSnapshot();
            return;
        }, {
            expect,
            createEngine: utils_2.createEngine,
            preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
        });
    });
    test("doesn't parse inline code block", () => {
        const resp = proc(engine, { dest }).parse("`((ref: [[foo.md]]))`");
        expect(resp).toMatchSnapshot("bond");
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("inlineCode");
    });
});
// future
// type TestCase<TData, TExpected> = {
//   testCase: string;
//   data: TData;
//   expected: TExpected;
// };
describe("compilev2", () => {
    const linkWithNoExtension = "((ref:[[foo]]))";
    const REGULAR_CASE = utils_2.createProcTests({
        name: "regular",
        setupFunc: async ({ engine, vaults, extra }) => {
            const proc2 = await utils_1.MDUtilsV4.procFull({
                engine,
                wikiLinksOpts: { useId: true },
                dest: extra.dest,
                vault: vaults[0],
            });
            const resp = await proc2.process(linkWithNoExtension);
            return { resp, proc };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [linkWithNoExtension],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
    });
    const WITH_ANCHOR_PRE_SETUP = async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await utils_2.modifyNote(opts, "foo", (note) => {
            const txt = [
                "---",
                "id: foo",
                "title: foo",
                "---",
                `# Tasks`,
                "## Header1",
                "task1",
                "## Header2",
                "task2",
            ];
            note.body = txt.join("\n");
            return note;
        });
    };
    const TITLE_IN_FM = utils_2.createProcTests({
        name: "TITLE_IN_FM",
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        setupFunc: async ({ engine, vaults, extra }) => {
            const proc2 = await utils_1.MDUtilsV4.procFull({
                engine,
                dest: extra.dest,
                fname: "foo",
                vault: vaults[0],
                publishOpts: { insertTitle: true },
            });
            return utils_2.processText({
                proc: proc2,
                text: "# Foo Bar\n((ref:[[foo]]#foo:#*))",
            });
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.HTML]: types_1.DendronASTDest.MD_ENHANCED_PREVIEW,
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(respProcess).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: respProcess.toString(),
                            match: ["# Foo", "# Tasks"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(respProcess).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: respProcess.toString(),
                            match: ["((ref:[[foo]]#foo:#*))"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
    });
    const RECURSIVE_TEST_CASES = utils_2.createProcTests({
        name: "recursive",
        setupFunc: async ({ engine, extra, vaults }) => {
            const resp = await utils_1.MDUtilsV4.procFull({
                engine,
                dest: extra.dest,
                vault: vaults[0],
            }).process(linkWithNoExtension);
            return { resp };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [linkWithNoExtension],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupNoteRefRecursive,
    });
    const WILDCARD_CASE = utils_2.createProcTests({
        name: "wildcard",
        setupFunc: async ({ engine, extra, vaults }) => {
            const note = engine.notes["id.journal"];
            // const resp = await proc(engine, {
            //   dest: extra.dest,
            //   vault: vaults[0],
            // }).process(note.body);
            const resp = await utils_1.MDUtilsV4.procFull({
                engine,
                dest: extra.dest,
                vault: vaults[0],
            }).process(note.body);
            return { resp };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra, engine }) => {
                const note = engine.notes["id.journal"];
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [note.body],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra, engine }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                // @ts-ignore
                return common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.genTestResults({
                    engine,
                    extra: { body: resp.toString() },
                });
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.preSetupHook,
    });
    const ALL_TEST_CASES = [
        ...REGULAR_CASE,
        ...RECURSIVE_TEST_CASES,
        ...WILDCARD_CASE,
        ...TITLE_IN_FM,
    ];
    //const ALL_TEST_CASES = WILDCARD_CASE;
    describe("compile", () => {
        test.each(ALL_TEST_CASES.map((ent) => [`${ent.dest}: ${ent.name}`, ent.testCase]))("%p", async (_key, testCase) => {
            await common_test_utils_1.runEngineTestV4(testCase.testFunc, {
                expect,
                createEngine: utils_2.createEngine,
                preSetupHook: testCase.preSetupHook,
            });
        });
    });
});
//# sourceMappingURL=noteRefs.spec.js.map