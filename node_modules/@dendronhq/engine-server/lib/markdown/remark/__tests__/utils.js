"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processNote = exports.processText = exports.modifyNote = exports.generateVerifyFunction = exports.createProcTests = exports.createProc = exports.createEngine = exports.basicSetup = void 0;
const common_server_1 = require("@dendronhq/common-server");
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const enginev2_1 = require("../../../enginev2");
const types_1 = require("../../types");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../../utils");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
exports.basicSetup = async ({ wsRoot, vaults }) => {
    await common_test_utils_1.NoteTestUtilsV4.createNote({
        wsRoot,
        fname: "foo",
        body: "foo body",
        vault: vaults[0],
        props: { id: "foo-id" },
    });
};
exports.createEngine = ({ vaults, wsRoot }) => {
    const logger = common_server_1.createLogger("testLogger", common_test_utils_1.getLogFilePath("engine-server"));
    const engine = enginev2_1.DendronEngineV2.createV3({ vaults, wsRoot, logger });
    return engine;
};
exports.createProc = async (opts, procOverride) => {
    const { engine, vaults, extra } = opts;
    const proc = await utils_1.MDUtilsV4.procFull(lodash_1.default.defaults({
        engine,
        dest: extra.dest,
        fname: "foo",
        vault: vaults[0],
    }, procOverride));
    return proc;
};
exports.createProcTests = (opts) => {
    const { name, setupFunc, verifyFuncDict } = opts;
    let allTests = [];
    if (verifyFuncDict) {
        allTests = Object.values(types_1.DendronASTDest)
            .map((dest) => {
            let funcOrKey = verifyFuncDict[dest];
            let verifyFunc;
            if (lodash_1.default.isUndefined(funcOrKey)) {
                return;
            }
            if (lodash_1.default.isString(funcOrKey)) {
                verifyFunc = verifyFuncDict[funcOrKey];
            }
            else {
                verifyFunc = funcOrKey;
            }
            return {
                name,
                dest,
                testCase: new common_test_utils_1.TestPresetEntryV4(async (presetOpts) => {
                    const extra = await setupFunc({
                        ...presetOpts,
                        extra: { dest },
                    });
                    return await verifyFunc({ ...presetOpts, extra });
                }, { preSetupHook: opts.preSetupHook }),
            };
        })
            .filter((ent) => !lodash_1.default.isUndefined(ent));
    }
    return allTests;
};
exports.generateVerifyFunction = (opts) => {
    const { target, exclude } = lodash_1.default.defaults(opts, { exclude: [] });
    const out = {};
    const excludeList = exclude.concat(target);
    Object.values(types_1.DendronASTDest)
        .filter((ent) => !lodash_1.default.includes(excludeList, ent))
        .forEach((ent) => {
        out[ent] = target;
    });
    return out;
};
exports.modifyNote = async (opts, fname, cb) => {
    await common_test_utils_1.NoteTestUtilsV4.modifyNoteByPath({ wsRoot: opts.wsRoot, vault: opts.vaults[0], fname }, cb);
};
exports.processText = (opts) => {
    const { text, proc } = opts;
    const respParse = proc.parse(text);
    const respProcess = proc.processSync(text);
    return { proc, respParse, respProcess };
};
exports.processNote = (opts) => {
    const { fname, wopts, proc } = opts;
    const npath = path_1.default.join(wopts.wsRoot, wopts.vaults[0].fsPath, fname + ".md");
    const text = fs_1.default.readFileSync(npath, { encoding: "utf8" });
    return exports.processText({ text, proc });
};
//# sourceMappingURL=utils.js.map