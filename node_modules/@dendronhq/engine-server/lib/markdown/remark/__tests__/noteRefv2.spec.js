"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_test_utils_1 = require("@dendronhq/common-test-utils");
const lodash_1 = __importDefault(require("lodash"));
const types_1 = require("../../types");
const utils_1 = require("../../utils");
const dendronPub_1 = require("../dendronPub");
const noteRefsV2_1 = require("../noteRefsV2");
const utils_2 = require("./utils");
function proc(engine, dendron, opts) {
    return utils_1.MDUtilsV4.proc({ engine })
        .data("dendron", dendron)
        .use(noteRefsV2_1.noteRefsV2, opts);
}
function createLink(opts) {
    const { fname, extra } = opts;
    const out = {
        link: {
            data: {
                type: "file",
            },
            from: {
                fname,
            },
            type: "ref",
        },
    };
    out.link = lodash_1.default.merge(out.link, extra);
    return out;
}
function checkLink(node, link) {
    const refNode = node.children[0].children[0];
    expect(refNode.type).toEqual("refLinkV2");
    expect(refNode.data).toEqual(link);
}
describe("parse", () => {
    let engine;
    let dest;
    test("init", () => {
        const resp = proc(engine, { dest }).parse(`![[foo.md]]))`);
        expect(resp).toMatchSnapshot();
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("refLinkV2");
    });
    test("without extension", () => {
        const resp = proc(engine, { dest }).parse(`![[foo]]))`);
        expect(resp).toMatchSnapshot();
        checkLink(resp, createLink({ fname: "foo" }));
    });
    test("with start anchor", () => {
        const resp = proc(engine, { dest }).parse(`![[foo#h1]]))`);
        expect(resp).toMatchSnapshot();
        checkLink(resp, createLink({
            fname: "foo",
            extra: {
                data: {
                    type: "file",
                    anchorStart: "h1",
                },
            },
        }));
    });
    test("with start and end", () => {
        const resp = proc(engine, { dest }).parse(`![[foo#h1:#h2]]))`);
        expect(resp).toMatchSnapshot();
        checkLink(resp, createLink({
            fname: "foo",
            extra: {
                data: {
                    type: "file",
                    anchorStart: "h1",
                    anchorEnd: "h2",
                },
            },
        }));
    });
    test("init with inject", async () => {
        await common_test_utils_1.runEngineTestV4(async ({ engine, vaults }) => {
            let _proc = proc(engine, { dest, vault: vaults[0] }).use(dendronPub_1.dendronPub);
            const resp = _proc.parse(`![[foo.md]]`);
            expect(resp).toMatchSnapshot();
            const resp2 = _proc.runSync(resp);
            expect(resp2).toMatchSnapshot();
            return;
        }, {
            expect,
            createEngine: utils_2.createEngine,
            preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
        });
    });
    test("doesn't parse inline code block", () => {
        const resp = proc(engine, { dest }).parse("`![[foo.md]]`");
        // @ts-ignore
        expect(resp.children[0].children[0].type).toEqual("inlineCode");
    });
});
describe("compilev2", () => {
    const linkWithNoExtension = "![[foo]]";
    const REGULAR_CASE = utils_2.createProcTests({
        name: "regular",
        setupFunc: async ({ engine, vaults, extra }) => {
            const proc2 = await utils_1.MDUtilsV4.procFull({
                engine,
                wikiLinksOpts: { useId: true },
                dest: extra.dest,
                vault: vaults[0],
            });
            const resp = await proc2.process(linkWithNoExtension);
            return { resp, proc };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [linkWithNoExtension],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["foo body", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupBasic,
    });
    const WITH_ANCHOR_PRE_SETUP = async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await utils_2.modifyNote(opts, "foo", (note) => {
            const txt = [
                "---",
                "id: foo",
                "title: foo",
                "---",
                `# Tasks`,
                "## Header1",
                "task1",
                "## Header2",
                "task2",
            ];
            note.body = txt.join("\n");
            return note;
        });
    };
    const ANCHOR_WITH_SPACE_PRE_SETUP = async (opts) => {
        await common_test_utils_1.ENGINE_HOOKS.setupBasic(opts);
        await utils_2.modifyNote(opts, "foo", (note) => {
            const txt = [
                "---",
                "id: foo",
                "---",
                `# Tasks`,
                "## Header 1",
                "task1",
                "## HeadeR 2",
                "task2",
            ];
            note.body = txt.join("\n");
            return note;
        });
    };
    const WITH_ANCHOR = utils_2.createProcTests({
        name: "WITH_ANCHOR",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, {});
            return utils_2.processText({ proc, text: "# Foo Bar\n![[foo#header2]]" });
        },
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["task2"],
                    nomatch: ["task1"],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["![[foo#header2]]"],
                })).toBeTruthy();
            },
            ...utils_2.generateVerifyFunction({
                target: types_1.DendronASTDest.MD_REGULAR,
                exclude: [types_1.DendronASTDest.MD_DENDRON],
            }),
        },
    });
    const WITH_FM_TITLE = utils_2.createProcTests({
        name: "WITH_FM_TITLE",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, { publishOpts: { insertTitle: true } });
            return utils_2.processText({ proc, text: "# Foo Bar\n![[foo#header2]]" });
        },
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(respProcess).toMatchSnapshot("bond");
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["task2"],
                    nomatch: ["task1"],
                })).toBeTruthy();
            },
        },
    });
    const WITH_ANCHOR_WITH_SPACE = utils_2.createProcTests({
        name: "WITH_ANCHOR",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, {});
            return utils_2.processText({ proc, text: "# Foo Bar\n![[foo#header-2]]" });
        },
        preSetupHook: ANCHOR_WITH_SPACE_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["task2"],
                    nomatch: ["task1"],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["![[foo#header-2]]"],
                })).toBeTruthy();
            },
            ...utils_2.generateVerifyFunction({
                target: types_1.DendronASTDest.MD_REGULAR,
                exclude: [types_1.DendronASTDest.MD_DENDRON],
            }),
        },
    });
    const WITH_START_ANCHOR_INVALID = utils_2.createProcTests({
        name: "WITH_START_ANCHOR_INVALID",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, {});
            return utils_2.processText({ proc, text: "# Foo Bar\n![[foo#badheader]]" });
        },
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["badheader not found"],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respParse, respProcess } = extra;
                expect(respParse).toMatchSnapshot();
                expect(respProcess).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["![[foo#badheader]]"],
                })).toBeTruthy();
            },
            ...utils_2.generateVerifyFunction({
                target: types_1.DendronASTDest.MD_REGULAR,
                exclude: [types_1.DendronASTDest.MD_DENDRON],
            }),
        },
    });
    const WITH_END_ANCHOR_INVALID = utils_2.createProcTests({
        name: "WITH_END_ANCHOR_INVALID",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, {});
            return utils_2.processText({
                proc,
                text: "# Foo Bar\n![[foo#header1:#badheader]]",
            });
        },
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["badheader not found"],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respParse, respProcess } = extra;
                expect(respParse).toMatchSnapshot();
                expect(respProcess).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["![[foo#header1:#badheader]]"],
                })).toBeTruthy();
            },
            ...utils_2.generateVerifyFunction({
                target: types_1.DendronASTDest.MD_REGULAR,
                exclude: [types_1.DendronASTDest.MD_DENDRON],
            }),
        },
    });
    const WITH_START_ANCHOR_OFFSET = utils_2.createProcTests({
        name: "WITH_START_ANCHOR_OFFSET",
        setupFunc: async (opts) => {
            let proc = await utils_2.createProc(opts, {});
            return utils_2.processText({ proc, text: "# Foo Bar\n![[foo#header2,1]]" });
        },
        preSetupHook: WITH_ANCHOR_PRE_SETUP,
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { respProcess } = extra;
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["[[foo#header2,1]]"],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { respParse, respProcess } = extra;
                expect(respParse).toMatchSnapshot();
                expect(respProcess).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: respProcess.toString(),
                    match: ["task2"],
                    nomatch: ["Header2", "task1"],
                })).toBeTruthy();
            },
            ...utils_2.generateVerifyFunction({
                target: types_1.DendronASTDest.MD_REGULAR,
                exclude: [types_1.DendronASTDest.MD_DENDRON],
            }),
        },
    });
    const RECURSIVE_TEST_CASES = utils_2.createProcTests({
        name: "recursive",
        setupFunc: async ({ engine, extra, vaults }) => {
            const resp = await utils_1.MDUtilsV4.procFull({
                engine,
                dest: extra.dest,
                vault: vaults[0],
            }).process(linkWithNoExtension);
            return { resp };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [linkWithNoExtension],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                return [
                    {
                        actual: await common_test_utils_1.AssertUtils.assertInString({
                            body: resp.toString(),
                            match: ["# Foo", "# Foo.One", "# Foo.Two", "portal"],
                        }),
                        expected: true,
                    },
                ];
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_HOOKS.setupNoteRefRecursive,
    });
    const WILDCARD_CASE = utils_2.createProcTests({
        name: "wildcard",
        setupFunc: async ({ engine, extra, vaults }) => {
            const note = engine.notes["id.journal"];
            // const resp = await proc(engine, {
            //   dest: extra.dest,
            //   vault: vaults[0],
            // }).process(note.body);
            const resp = await utils_1.MDUtilsV4.procFull({
                engine,
                dest: extra.dest,
                vault: vaults[0],
            }).process(note.body);
            return { resp };
        },
        verifyFuncDict: {
            [types_1.DendronASTDest.MD_DENDRON]: async ({ extra, engine }) => {
                const note = engine.notes["id.journal"];
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                expect(await common_test_utils_1.AssertUtils.assertInString({
                    body: resp.contents,
                    match: [note.body],
                })).toBeTruthy();
            },
            [types_1.DendronASTDest.MD_REGULAR]: async ({ extra, engine }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
                // @ts-ignore
                return common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.genTestResults({
                    engine,
                    extra: { body: resp.toString() },
                });
            },
            [types_1.DendronASTDest.HTML]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
            [types_1.DendronASTDest.MD_ENHANCED_PREVIEW]: async ({ extra }) => {
                const { resp } = extra;
                expect(resp).toMatchSnapshot();
            },
        },
        preSetupHook: common_test_utils_1.ENGINE_SERVER.NOTE_REF.WILDCARD_LINK_V4.preSetupHook,
    });
    const ALL_TEST_CASES = [
        ...REGULAR_CASE,
        ...RECURSIVE_TEST_CASES,
        ...WILDCARD_CASE,
        ...WITH_ANCHOR,
        ...WITH_FM_TITLE,
        ...WITH_ANCHOR_WITH_SPACE,
        ...WITH_START_ANCHOR_INVALID,
        ...WITH_END_ANCHOR_INVALID,
        ...WITH_START_ANCHOR_OFFSET,
    ];
    describe("compile", () => {
        test.each(ALL_TEST_CASES.map((ent) => [`${ent.dest}: ${ent.name}`, ent.testCase]))("%p", async (_key, testCase) => {
            await common_test_utils_1.runEngineTestV4(testCase.testFunc, {
                expect,
                createEngine: utils_2.createEngine,
                preSetupHook: testCase.preSetupHook,
            });
        });
    });
});
//# sourceMappingURL=noteRefv2.spec.js.map